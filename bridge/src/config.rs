//! Configuration file module

pub(crate) mod dhcp;

use std::{collections::HashMap, fs::File, io, net::SocketAddr, path::Path};

use serde::{de::DeserializeOwned, Deserialize, Serialize};
use shadesmar_net::types::Ipv4Network;
use uuid::Uuid;

use crate::{
    config::dhcp::DhcpConfig,
    net::wan::{TapConfig, WgConfig},
};

pub trait YamlConfig: Sized {
    fn read_yaml_from_file(path: &Path) -> io::Result<Self>;
}

/// Shadesmar network configuration
///
/// A network config consists of three main sections:
/// - wan: The various upstream / wide area network connections
/// - router: Various router configuration settings
/// - virtio: Virtio configuration settings
#[derive(Debug, Deserialize, Serialize)]
pub struct Config {
    pub wan: Vec<WanConfig>,
    pub router: RouterConfig,
}

/// Contains all information needed to initialize a WAN connection
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "lowercase")]
pub struct WanConfig {
    /// Unique id of wan (autogenerated if left blank)
    #[serde(default = "Uuid::now_v7")]
    pub id: Uuid,

    /// Human-friendly name for WAN connection
    pub name: String,

    /// True to capture any packets trasmitted via this WAN
    #[serde(default)]
    pub pcap: bool,

    /// WAN-device specific configuration
    pub device: WanDevice,
}

/// Various different types of WAN devices supported by shadesmar
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum WanDevice {
    /// Pcap device (drops all packets)
    Blackhole,

    /// A generic tap device
    Tap(TapConfig),

    /// Forwards traffic to a UDP socket
    Udp(UdpConfig),

    /// Forwards all traffic over a wireguard socket
    Wireguard(WgConfig),
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct UdpConfig {
    pub endpoint: SocketAddr,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RouterConfig {
    pub ipv4: Ipv4Network,
    pub dhcp: DhcpConfig,
    pub dns: bool,
    pub table: HashMap<Ipv4Network, String>,
}

impl Config {
    /// Loads a configuration file from disk
    ///
    /// ### Arguments
    /// * `path` - Path to the configuration file
    pub fn load<P: AsRef<Path>>(path: P) -> io::Result<Self> {
        let f = File::open(path)?;
        let cfg: Config =
            serde_yaml::from_reader(f).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
        Ok(cfg)
    }
}

impl<T> YamlConfig for T
where
    T: DeserializeOwned,
{
    fn read_yaml_from_file(path: &Path) -> io::Result<Self> {
        let file = File::open(path)?;
        let cfg: T = serde_yaml::from_reader(file).map_err(|e| io::Error::other(e))?;
        Ok(cfg)
    }
}
