//! Plugin Support

mod macros;
mod vtable;

use std::{
    borrow::Cow,
    collections::HashMap,
    ffi::{c_char, c_void, CStr, CString},
    path::{Path, PathBuf},
};

use libloading::{Library, Symbol};
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use uuid::Uuid;

pub use self::vtable::WanPlugin;

pub type FnCallback = extern "C" fn(*const c_void, *const u8, *const u8, usize) -> i32;
type FnInit = fn(*const WanPluginInitOptions) -> i32;

/// Error type for any errors generated by a plugin
#[derive(Debug, thiserror::Error)]
pub enum PluginError {
    #[error("failed to load library: {0}")]
    Load(#[from] libloading::Error),

    #[error("plugin not loaded or missing: {0}")]
    PluginNotFound(String),

    #[error("symbol not found in library: {0}")]
    SymbolNotFound(&'static str),

    #[error("null pointer!")]
    NulPointer,

    #[error("ffi: {0}")]
    FFI(#[from] std::ffi::NulError),

    #[error("utf8: {0}")]
    UTF8(#[from] std::str::Utf8Error),

    #[error("json: {0}")]
    Json(#[from] serde_json::Error),

    #[error("plugin failed to spawn an instance")]
    SpawnFailed,

    #[error("{0}")]
    Other(String),
}

/// New Type to wrap an opaque pointer to a WAN device
pub struct WanDevice {
    ptr: *const c_void,
}

/// New Type to wrap an opaque pointer to a WAN instance
pub struct WanInstance {
    obj: *const c_void,
    channel: *mut c_void,
}

/// Contains references to all loaded plugin libraries
pub struct WanPlugins {
    libs: HashMap<String, Library>,
}

impl WanPluginConfig<()> {
    /// Serializes a plugin's configuration into a CString (null-terminated)
    ///
    /// ### Arguments
    /// * `id` - Unique id of WAN plugin
    /// * `router` - Path to router's socket
    /// * `device` - Device specific configuration
    pub fn as_json(id: Uuid, device: &HashMap<String, String>) -> Result<CString, PluginError> {
        let s = serde_json::json!({
            "id": id,
            "device": device
        })
        .to_string();

        let cs = CString::new(s)?;

        Ok(cs)
    }
}

impl<T> PluginMessage for T
where
    T: Serialize + DeserializeOwned,
{
    /// Serializes a struct to json and converts it to a CString to
    /// be passed over an FFI barrier / function call
    fn as_plugin_message(&self) -> Result<CString, PluginError> {
        let params = serde_json::to_string(self)?;
        let params = CString::new(params)?;

        Ok(params)
    }

    /// Deserializes a message received over the ffi barrier
    fn from_plugin_message(data: *const c_char) -> Result<Self, PluginError> {
        let data = unsafe { CStr::from_ptr(data) };
        let params = data.to_str()?;
        let params: Self = serde_json::from_str(params)?;
        Ok(params)
    }
}

impl WanPluginInitOptions {
    /// Creates a new plugin init options to initialize a plugin
    ///
    /// ### Arguments
    /// * `log_level` - Level at which to install tracing logger
    pub fn new(log_level: u8) -> Self {
        Self { log_level }
    }
}

impl<'a> WanPluginStartOpts<'a> {
    /// Creates a new plugin start options struct from borrowed params
    pub fn new(router: &'a Path, socket: &'a Path) -> Self {
        Self {
            router: Cow::Borrowed(router),
            socket: Cow::Borrowed(socket),
        }
    }
}

impl PluginError {
    pub fn as_i32(&self) -> i32 {
        match self {
            Self::Load(_error_) => -1,
            Self::PluginNotFound(_plugin) => -2,
            Self::SymbolNotFound(_symbol) => -3,
            Self::NulPointer => -4,
            Self::FFI(_ffi) => -5,
            Self::UTF8(_error) => -6,
            Self::Json(_error) => -7,
            Self::SpawnFailed => -8,
            Self::Other(_error) => -9,
        }
    }
}

pub trait PluginMessage: Sized {
    /// Serializes a struct to json and converts it to a CString to
    /// be passed over an FFI barrier / function call
    fn as_plugin_message(&self) -> Result<CString, PluginError>;

    /// Deserializes a message received over the ffi barrier
    fn from_plugin_message(data: *const c_char) -> Result<Self, PluginError>;
}

/// Options passed to the initialziation FFI function
#[derive(Debug, Deserialize, Serialize)]
#[repr(C)]
pub struct WanPluginInitOptions {
    /// Verbosity level to which to produce logs
    pub log_level: u8,
}

/// Configuration data for a WAN plugin
///
/// WAN plugin configuration is generic over T, where T is the specific type
/// of plugin being configured. This allows each plugin to specify its own
/// configuration type and not expose it to the larger application.
///
/// For example, the simple `blackhole` wan driver specifies a config type
/// of `BlackholeConfig` that takes no parameters (aka the unit type `()`).
/// The WireGuard wan driver specifies a config type of `WgConfig` that contains
/// information about the WireGuard endpoint
#[derive(Debug, Deserialize, Serialize)]
pub struct WanPluginConfig<T> {
    /// WAN unique identifier
    pub id: Uuid,

    /// Device-specific settings
    pub device: T,
}

/// Contains options passed to the plugin when an instance is started
///
/// These should be runtime settings and are not required to be persistent
/// over the lifetime of a device.
#[derive(Debug, Deserialize, Serialize)]
pub struct WanPluginStartOpts<'a> {
    /// Path to the router's socket
    pub router: Cow<'a, Path>,

    /// Path to wan plugin socket
    pub socket: Cow<'a, Path>,
}

impl PluginError {
    pub fn new<S: Into<String>>(msg: S) -> Self {
        PluginError::Other(msg.into())
    }
}

impl WanPlugins {
    /// Loads all plugins from a list
    ///
    /// ### Arguments
    /// * `plugins` - List of plugins to load
    /// * `opts` - Global plugin configuration object
    pub fn init(
        plugins: HashMap<String, PathBuf>,
        opts: WanPluginInitOptions,
    ) -> Result<Self, PluginError> {
        let mut libs = HashMap::new();
        for (name, plugin) in plugins {
            // SAFETY:
            // Ensure all so/dll init and termination routies are safe
            let lib = unsafe { Library::new(&plugin) }?;
            let init: Symbol<FnInit> = unsafe { lib.get(b"init") }?;
            match init(&opts) {
                0 => {
                    tracing::trace!("registering plugin: {name}");
                    libs.insert(name, lib);
                }
                _ => {
                    tracing::warn!("plugin missing init function, not loading");
                }
            }
        }

        Ok(Self { libs })
    }

    /// Returns the virtual table (vtable) for a plugin
    ///
    /// A vtable contains all the functions necessary to interact with a given wan plugin
    ///
    /// ### Arguments
    /// * `plugin` - Name of the plugin for which to retrieve the vtable
    pub fn get_vtable<'a, S: AsRef<str>>(
        &'a self,
        plugin: S,
    ) -> Result<WanPlugin<'a>, PluginError> {
        let plugin = plugin.as_ref();

        let lib = self
            .libs
            .get(plugin)
            .ok_or_else(|| PluginError::PluginNotFound(plugin.to_owned()))?;

        WanPlugin::new(lib)
    }
}

// SAFETY:
// Both `WandDevice` and `WanInstance` represent opaque pointers to
// structures allocated by plugins. They are never accessed except from
// the context of the shared library/plugin from which they were created.
unsafe impl Send for WanDevice {}
unsafe impl Sync for WanDevice {}
unsafe impl Send for WanInstance {}
unsafe impl Sync for WanInstance {}
